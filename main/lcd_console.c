/*
 * LCD Console Driver for ESP32-P4
 * Mirrors serial console output to ST7796S SPI LCD display
 */

#include "lcd_console.h"
#include <string.h>
#include <stdlib.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "esp_log.h"
#include "esp_heap_caps.h"
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_vendor.h"
#include "driver/gpio.h"
#include "driver/spi_master.h"

static const char *TAG = "lcd_console";

// ST7796S 4.0" 320x480 SPI LCD pins (ESP32-P4-NANO board)
// Using available GPIOs from the NANO pinout
#define LCD_PIN_NUM_MOSI    27  // GPIO27 - USBIP1_P1 (SPI MOSI)
#define LCD_PIN_NUM_CLK     24  // GPIO24 - USBIP1_N0 (SPI CLK)
#define LCD_PIN_NUM_CS      22  // GPIO22 (SPI CS)
#define LCD_PIN_NUM_DC      4   // GPIO4 - TOUCH_CHANNEL2 (LCD DC/RS)
#define LCD_PIN_NUM_RST     6   // GPIO6 - TOUCH_CHANNEL4 (LCD RST, moved from GPIO38)
#define LCD_PIN_NUM_BL      48  // GPIO48 (Backlight PWM)

// SPI configuration
#define LCD_SPI_HOST        SPI2_HOST
#define LCD_PIXEL_CLOCK_HZ  (40 * 1000 * 1000)  // 40MHz
#define LCD_CMD_BITS        8
#define LCD_PARAM_BITS      8

// DMA bounce buffer strip size - PSRAM can't be sent directly via SPI DMA
#define LCD_DMA_STRIP_HEIGHT  CONSOLE_FONT_HEIGHT  // 16 rows per strip
#define LCD_DMA_STRIP_SIZE    (LCD_H_RES * LCD_DMA_STRIP_HEIGHT * sizeof(uint16_t))  // 15360 bytes

// Simple 8x16 bitmap font (ASCII 32-126)
// Each character is 8 pixels wide, 16 pixels tall
// Stored as 16 bytes per character (one byte per row)
static const uint8_t font_8x16[][16] = {
    // Space (32)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // ! (33)
    {0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // " (34)
    {0x00,0x63,0x63,0x63,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // # (35)
    {0x00,0x00,0x00,0x36,0x36,0x7F,0x36,0x36,0x36,0x7F,0x36,0x36,0x00,0x00,0x00,0x00},
    // $ (36)
    {0x0C,0x0C,0x3E,0x63,0x61,0x60,0x3E,0x03,0x03,0x43,0x63,0x3E,0x0C,0x0C,0x00,0x00},
    // % (37)
    {0x00,0x00,0x00,0x00,0x00,0x61,0x63,0x06,0x0C,0x18,0x33,0x63,0x00,0x00,0x00,0x00},
    // & (38)
    {0x00,0x00,0x00,0x1C,0x36,0x36,0x1C,0x3B,0x6E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00},
    // ' (39)
    {0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // ( (40)
    {0x00,0x00,0x0C,0x18,0x18,0x30,0x30,0x30,0x30,0x18,0x18,0x0C,0x00,0x00,0x00,0x00},
    // ) (41)
    {0x00,0x00,0x18,0x0C,0x0C,0x06,0x06,0x06,0x06,0x0C,0x0C,0x18,0x00,0x00,0x00,0x00},
    // * (42)
    {0x00,0x00,0x00,0x00,0x42,0x66,0x3C,0xFF,0x3C,0x66,0x42,0x00,0x00,0x00,0x00,0x00},
    // + (43)
    {0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x7E,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // , (44)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00},
    // - (45)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // . (46)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // / (47)
    {0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00},
    // 0 (48)
    {0x00,0x00,0x3C,0x66,0xC3,0xC3,0xDB,0xDB,0xC3,0xC3,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 1 (49)
    {0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00},
    // 2 (50)
    {0x00,0x00,0x3C,0x66,0x06,0x06,0x0C,0x18,0x30,0x60,0x66,0x7E,0x00,0x00,0x00,0x00},
    // 3 (51)
    {0x00,0x00,0x3C,0x66,0x06,0x06,0x1C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 4 (52)
    {0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00},
    // 5 (53)
    {0x00,0x00,0x7E,0x60,0x60,0x60,0x7C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 6 (54)
    {0x00,0x00,0x1C,0x30,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 7 (55)
    {0x00,0x00,0x7E,0x66,0x06,0x0C,0x0C,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00},
    // 8 (56)
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 9 (57)
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3E,0x06,0x06,0x06,0x0C,0x38,0x00,0x00,0x00,0x00},
    // : (58)
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // ; (59)
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00},
    // < (60)
    {0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00},
    // = (61)
    {0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // > (62)
    {0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00},
    // ? (63)
    {0x00,0x00,0x3C,0x66,0x66,0x06,0x0C,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // @ (64)
    {0x00,0x00,0x00,0x3C,0x42,0x5A,0x5A,0x5A,0x5C,0x40,0x40,0x3C,0x00,0x00,0x00,0x00},
    // A (65)
    {0x00,0x00,0x18,0x3C,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // B (66)
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00},
    // C (67)
    {0x00,0x00,0x3C,0x66,0x66,0x60,0x60,0x60,0x60,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // D (68)
    {0x00,0x00,0x78,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0x78,0x00,0x00,0x00,0x00},
    // E (69)
    {0x00,0x00,0x7E,0x60,0x60,0x60,0x78,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00},
    // F (70)
    {0x00,0x00,0x7E,0x60,0x60,0x60,0x78,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00},
    // G (71)
    {0x00,0x00,0x3C,0x66,0x66,0x60,0x60,0x6E,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00},
    // H (72)
    {0x00,0x00,0x66,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // I (73)
    {0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // J (74)
    {0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x6C,0x6C,0x38,0x00,0x00,0x00,0x00},
    // K (75)
    {0x00,0x00,0x66,0x66,0x6C,0x6C,0x78,0x78,0x6C,0x6C,0x66,0x66,0x00,0x00,0x00,0x00},
    // L (76)
    {0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00},
    // M (77)
    {0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // N (78)
    {0x00,0x00,0x66,0x66,0x76,0x76,0x7E,0x6E,0x6E,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // O (79)
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // P (80)
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00},
    // Q (81)
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x6E,0x3C,0x06,0x00,0x00,0x00},
    // R (82)
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x78,0x6C,0x6C,0x66,0x66,0x00,0x00,0x00,0x00},
    // S (83)
    {0x00,0x00,0x3C,0x66,0x60,0x60,0x3C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00},
    // T (84)
    {0x00,0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00},
    // U (85)
    {0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // V (86)
    {0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00},
    // W (87)
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // X (88)
    {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // Y (89)
    {0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00},
    // Z (90)
    {0x00,0x00,0x7E,0x06,0x06,0x0C,0x18,0x30,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00},
    // [ (91)
    {0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00},
    // \ (92)
    {0x00,0x00,0x00,0x80,0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00,0x00,0x00,0x00},
    // ] (93)
    {0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00},
    // ^ (94)
    {0x18,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // _ (95)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},
    // ` (96)
    {0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // a (97)
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00},
    // b (98)
    {0x00,0x00,0x60,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00},
    // c (99)
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00,0x00,0x00,0x00},
    // d (100)
    {0x00,0x00,0x06,0x06,0x06,0x3E,0x66,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00},
    // e (101)
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x66,0x7E,0x60,0x60,0x3C,0x00,0x00,0x00,0x00},
    // f (102)
    {0x00,0x00,0x1C,0x36,0x30,0x30,0x7C,0x30,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00},
    // g (103)
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x3C,0x00,0x00},
    // h (104)
    {0x00,0x00,0x60,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // i (105)
    {0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // j (106)
    {0x00,0x00,0x0C,0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x6C,0x6C,0x38,0x00,0x00},
    // k (107)
    {0x00,0x00,0x60,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0x66,0x00,0x00,0x00,0x00},
    // l (108)
    {0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // m (109)
    {0x00,0x00,0x00,0x00,0x00,0x6C,0xFE,0xD6,0xD6,0xD6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // n (110)
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // o (111)
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // p (112)
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x00,0x00},
    // q (113)
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x06,0x00,0x00},
    // r (114)
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00},
    // s (115)
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x60,0x60,0x3C,0x06,0x06,0x7C,0x00,0x00,0x00,0x00},
    // t (116)
    {0x00,0x00,0x00,0x30,0x30,0x7C,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00},
    // u (117)
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00},
    // v (118)
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00},
    // w (119)
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00},
    // x (120)
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x3C,0x3C,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // y (121)
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x3E,0x06,0x0C,0x78,0x00,0x00},
    // z (122)
    {0x00,0x00,0x00,0x00,0x00,0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00,0x00,0x00,0x00},
    // { (123)
    {0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00},
    // | (124)
    {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00},
    // } (125)
    {0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00},
    // ~ (126)
    {0x00,0x00,0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
};

// Console state
typedef struct {
    // LCD hardware handles
    esp_lcd_panel_handle_t panel_handle;
    esp_lcd_panel_io_handle_t io_handle;
    
    // Text buffer
    char text_buffer[CONSOLE_ROWS][CONSOLE_COLS + 1];
    
    // Cursor position
    int cursor_col;
    int cursor_row;
    
    // Colors (RGB565)
    uint16_t fg_color;
    uint16_t bg_color;
    
    // Flags
    bool initialized;
    bool cursor_visible;
    bool defer_flip;  // When true, putchar skips the SPI flip (batching mode)
    
    // Framebuffer (for a section of the screen)
    uint16_t *line_buffer;  // RGB565 in PSRAM
    size_t line_buffer_size;
    
    // DMA bounce buffer in internal RAM for SPI transfers
    uint16_t *dma_buffer;
    size_t dma_buffer_size;
    
    // Mutex for thread safety
    SemaphoreHandle_t mutex;
} lcd_console_t;

static lcd_console_t *console = NULL;

// Forward declarations
static void lcd_console_flip_buffer(void);
static void draw_char(int col, int row, char c);
static void render_line(int row);
static void render_screen(void);

// Convert RGB888 to RGB565
static inline uint16_t rgb888_to_rgb565(uint32_t rgb888) {
    uint8_t r = (rgb888 >> 16) & 0xFF;
    uint8_t g = (rgb888 >> 8) & 0xFF;
    uint8_t b = rgb888 & 0xFF;
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}

esp_err_t lcd_console_init(void)
{
    esp_err_t ret;
    
    if (console != NULL && console->initialized) {
        ESP_LOGW(TAG, "LCD console already initialized");
        return ESP_OK;
    }
    
    // Allocate console state
    console = heap_caps_calloc(1, sizeof(lcd_console_t), MALLOC_CAP_DEFAULT);
    if (console == NULL) {
        ESP_LOGE(TAG, "Failed to allocate console state");
        return ESP_ERR_NO_MEM;
    }
    
    // Initialize defaults (RGB565 colors)
    console->fg_color = rgb888_to_rgb565(CONSOLE_FG_COLOR);
    console->bg_color = rgb888_to_rgb565(CONSOLE_BG_COLOR);
    console->cursor_visible = true;
    
    // Create mutex
    console->mutex = xSemaphoreCreateMutex();
    if (console->mutex == NULL) {
        ESP_LOGE(TAG, "Failed to create mutex");
        free(console);
        console = NULL;
        return ESP_ERR_NO_MEM;
    }
    
    // Configure backlight GPIO
    if (LCD_PIN_NUM_BL >= 0) {
        gpio_config_t bk_gpio_config = {
            .mode = GPIO_MODE_OUTPUT,
            .pin_bit_mask = 1ULL << LCD_PIN_NUM_BL
        };
        gpio_config(&bk_gpio_config);
        gpio_set_level(LCD_PIN_NUM_BL, 1);  // Turn on backlight
    }
    
    // Initialize SPI bus
    ESP_LOGI(TAG, "Initializing SPI bus...");
    // DMA bounce buffer: one strip of 16 rows (15KB) in internal DMA-capable RAM
    // PSRAM framebuffer can't be sent directly via SPI DMA on ESP32-P4
    
    spi_bus_config_t buscfg = {
        .mosi_io_num = LCD_PIN_NUM_MOSI,
        .miso_io_num = -1,
        .sclk_io_num = LCD_PIN_NUM_CLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = LCD_DMA_STRIP_SIZE
    };
    ret = spi_bus_initialize(LCD_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK && ret != ESP_ERR_INVALID_STATE) {
        ESP_LOGE(TAG, "Failed to initialize SPI bus: %s", esp_err_to_name(ret));
        goto cleanup;
    }
    
    // Allocate DMA bounce buffer in internal RAM (required for SPI DMA)
    console->dma_buffer_size = LCD_DMA_STRIP_SIZE;
    console->dma_buffer = heap_caps_malloc(LCD_DMA_STRIP_SIZE, MALLOC_CAP_DMA | MALLOC_CAP_INTERNAL);
    if (console->dma_buffer == NULL) {
        ESP_LOGE(TAG, "Failed to allocate DMA bounce buffer");
        ret = ESP_ERR_NO_MEM;
        goto cleanup;
    }
    ESP_LOGI(TAG, "Allocated %d byte DMA bounce buffer in internal RAM", LCD_DMA_STRIP_SIZE);
    
    // Create panel IO handle (no callback = synchronous/polling mode)
    ESP_LOGI(TAG, "Creating panel IO...");
    esp_lcd_panel_io_spi_config_t io_config = {
        .dc_gpio_num = LCD_PIN_NUM_DC,
        .cs_gpio_num = LCD_PIN_NUM_CS,
        .pclk_hz = LCD_PIXEL_CLOCK_HZ,
        .lcd_cmd_bits = LCD_CMD_BITS,
        .lcd_param_bits = LCD_PARAM_BITS,
        .spi_mode = 0,
        .trans_queue_depth = 10,
    };
    ret = esp_lcd_new_panel_io_spi((esp_lcd_spi_bus_handle_t)LCD_SPI_HOST, &io_config, &console->io_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create panel IO: %s", esp_err_to_name(ret));
        goto cleanup;
    }
    
    // Create ST7796S LCD panel - use ST7789 driver as base (compatible command set)
    ESP_LOGI(TAG, "Creating ST7796S panel...");
    esp_lcd_panel_dev_config_t panel_config = {
        .reset_gpio_num = LCD_PIN_NUM_RST,
        .rgb_ele_order = LCD_RGB_ELEMENT_ORDER_RGB,  // Standard RGB565 data format
        .bits_per_pixel = LCD_BIT_PER_PIXEL,
    };
    ret = esp_lcd_new_panel_st7789(console->io_handle, &panel_config, &console->panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create panel: %s", esp_err_to_name(ret));
        goto cleanup;
    }
    
    // Reset and initialize panel
    ESP_LOGI(TAG, "Initializing panel...");
    ret = esp_lcd_panel_reset(console->panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to reset panel: %s", esp_err_to_name(ret));
        goto cleanup;
    }
    
    ret = esp_lcd_panel_init(console->panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to init panel: %s", esp_err_to_name(ret));
        goto cleanup;
    }
    
    // Fix display orientation: landscape mode, 180° rotation (flip upside down)
    ESP_LOGI(TAG, "Configuring display orientation (180° rotation)...");
    
    // Rotate to landscape + 180° flip
    ret = esp_lcd_panel_swap_xy(console->panel_handle, true);  // Swap X/Y for 90° rotation
    if (ret != ESP_OK) {
        ESP_LOGW(TAG, "Failed to swap XY: %s", esp_err_to_name(ret));
    }
    
    // Mirror both X and Y to flip 180 degrees
    ret = esp_lcd_panel_mirror(console->panel_handle, true, true);  // Mirror X and Y for 180° flip
    if (ret != ESP_OK) {
        ESP_LOGW(TAG, "Failed to set mirror: %s", esp_err_to_name(ret));
    }
    
    ret = esp_lcd_panel_disp_on_off(console->panel_handle, true);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to turn on display: %s", esp_err_to_name(ret));
        goto cleanup;
    }
    
    ESP_LOGI(TAG, "Display turned on successfully");
    
    // Allocate full-screen frame buffer (DOS-style video card buffer)
    // This enables instant frame flipping for smooth DOS-like updates
    console->line_buffer_size = LCD_H_RES * LCD_V_RES;  // Full screen buffer
    console->line_buffer = heap_caps_malloc(console->line_buffer_size * sizeof(uint16_t), MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    if (console->line_buffer == NULL) {
        ESP_LOGE(TAG, "Failed to allocate frame buffer in PSRAM");
        ret = ESP_ERR_NO_MEM;
        goto cleanup;
    }
    
    ESP_LOGI(TAG, "Allocated %d KB frame buffer for DOS-style rendering", (console->line_buffer_size * 2) / 1024);
    
    console->initialized = true;
    
    // Clear frame buffer to black (DOS boot style)
    ESP_LOGI(TAG, "Initializing frame buffer...");
    memset(console->line_buffer, 0x00, console->line_buffer_size * sizeof(uint16_t));
    
    // Flip buffer to screen for instant display
    lcd_console_flip_buffer();
    
    ESP_LOGI(TAG, "LCD console initialized: %dx%d chars (%dx%d pixels)", 
             CONSOLE_COLS, CONSOLE_ROWS, LCD_H_RES, LCD_V_RES);
    return ESP_OK;

cleanup:
    lcd_console_deinit();
    return ret;
}

void lcd_console_deinit(void)
{
    if (console == NULL) {
        return;
    }
    
    if (console->line_buffer) {
        heap_caps_free(console->line_buffer);
    }
    
    if (console->dma_buffer) {
        heap_caps_free(console->dma_buffer);
    }
    
    if (console->panel_handle) {
        esp_lcd_panel_del(console->panel_handle);
    }
    
    if (console->io_handle) {
        esp_lcd_panel_io_del(console->io_handle);
    }
    
    // SPI bus is shared, don't deinitialize it here
    
    if (console->mutex) {
        vSemaphoreDelete(console->mutex);
    }
    
    free(console);
    console = NULL;
    
    ESP_LOGI(TAG, "LCD console deinitialized");
}

// Render a single character to the line buffer at given pixel position
static void render_char_to_buffer(uint16_t *buffer, int x_offset, int y_offset, 
                                   int buffer_width, char c, uint16_t fg, uint16_t bg)
{
    int char_index = c - 32;
    if (char_index < 0 || char_index > 94) {
        char_index = 0;  // Default to space for out-of-range chars
    }
    
    const uint8_t *glyph = font_8x16[char_index];
    
    for (int row = 0; row < CONSOLE_FONT_HEIGHT; row++) {
        uint8_t row_data = glyph[row];
        for (int col = 0; col < CONSOLE_FONT_WIDTH; col++) {
            int px = x_offset + col;
            int py = y_offset + row;
            int idx = py * buffer_width + px;
            
            if (row_data & (0x80 >> col)) {
                buffer[idx] = fg;
            } else {
                buffer[idx] = bg;
            }
        }
    }
}

// DOS-style frame buffer flip - send PSRAM framebuffer to LCD via DMA bounce buffer
// The PSRAM framebuffer can't be sent directly via SPI DMA on ESP32-P4,
// so we copy strips to an internal DMA buffer and send one strip at a time.
static void lcd_console_flip_buffer(void)
{
    if (!console || !console->initialized || !console->line_buffer || !console->dma_buffer) {
        return;
    }
    
    // Skip flip if we're in batch mode (lcd_console_print will flip once at end)
    if (console->defer_flip) {
        return;
    }
    
    // Send framebuffer to LCD in strips via internal DMA bounce buffer
    // Each strip is LCD_DMA_STRIP_HEIGHT rows (16 pixels = one text row)
    for (int y = 0; y < LCD_V_RES; y += LCD_DMA_STRIP_HEIGHT) {
        int strip_h = LCD_DMA_STRIP_HEIGHT;
        if (y + strip_h > LCD_V_RES) {
            strip_h = LCD_V_RES - y;
        }
        
        // Copy strip from PSRAM framebuffer to internal DMA buffer
        size_t strip_bytes = LCD_H_RES * strip_h * sizeof(uint16_t);
        memcpy(console->dma_buffer, console->line_buffer + (y * LCD_H_RES), strip_bytes);
        
        // Send strip to LCD (synchronous - blocks until SPI transfer complete)
        esp_lcd_panel_draw_bitmap(console->panel_handle, 0, y, LCD_H_RES, y + strip_h, console->dma_buffer);
    }
}

// Render and send a single text row to the frame buffer
static void render_line(int row)
{
    if (!console || !console->initialized || row < 0 || row >= CONSOLE_ROWS) {
        return;
    }
    
    int y_start = row * CONSOLE_FONT_HEIGHT;
    uint16_t *row_buffer = console->line_buffer + (y_start * LCD_H_RES);
    
    // Render each character in the row directly to frame buffer
    for (int col = 0; col < CONSOLE_COLS; col++) {
        char c = console->text_buffer[row][col];
        if (c == '\0') c = ' ';
        if (c < 32 || c > 126) c = ' ';
        
        render_char_to_buffer(row_buffer, 
                              col * CONSOLE_FONT_WIDTH, 0,
                              LCD_H_RES, c,
                              console->fg_color, console->bg_color);
    }
    
    // Draw cursor if on this line
    if (console->cursor_visible && row == console->cursor_row) {
        int cx = console->cursor_col * CONSOLE_FONT_WIDTH;
        for (int py = 0; py < CONSOLE_FONT_HEIGHT; py++) {
            for (int px = 0; px < CONSOLE_FONT_WIDTH; px++) {
                int idx = py * LCD_H_RES + cx + px;
                row_buffer[idx] = ~row_buffer[idx];
            }
        }
    }
}

// Render entire screen to frame buffer, then flip (DOS-style)
static void render_screen(void)
{
    if (!console || !console->initialized) {
        return;
    }
    
    // Clear frame buffer to background color
    for (size_t i = 0; i < console->line_buffer_size; i++) {
        console->line_buffer[i] = console->bg_color;
    }
    
    // Render all rows to frame buffer
    for (int row = 0; row < CONSOLE_ROWS; row++) {
        render_line(row);
    }
    
    // Flip entire buffer to screen instantly (DOS VGA-style)
    lcd_console_flip_buffer();
}

void lcd_console_clear(void)
{
    if (!console || !console->initialized) {
        return;
    }
    
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    
    // Clear text buffer
    memset(console->text_buffer, ' ', sizeof(console->text_buffer));
    for (int row = 0; row < CONSOLE_ROWS; row++) {
        console->text_buffer[row][CONSOLE_COLS] = '\0';
    }
    
    // Reset cursor
    console->cursor_col = 0;
    console->cursor_row = 0;
    
    // Render black screen
    render_screen();
    
    xSemaphoreGive(console->mutex);
}

void lcd_console_putchar(char c)
{
    if (!console || !console->initialized) {
        return;
    }
    
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    
    int old_row = console->cursor_row;
    bool need_scroll = false;
    
    switch (c) {
        case '\n':  // Newline
            console->cursor_row++;
            console->cursor_col = 0;
            break;
            
        case '\r':  // Carriage return
            console->cursor_col = 0;
            break;
            
        case '\t':  // Tab
            console->cursor_col = (console->cursor_col + 8) & ~7;
            if (console->cursor_col >= CONSOLE_COLS) {
                console->cursor_col = 0;
                console->cursor_row++;
            }
            break;
            
        case '\b':  // Backspace
            if (console->cursor_col > 0) {
                console->cursor_col--;
                console->text_buffer[console->cursor_row][console->cursor_col] = ' ';
            }
            break;
            
        default:
            if (c >= 32 && c <= 126) {
                console->text_buffer[console->cursor_row][console->cursor_col] = c;
                console->cursor_col++;
                if (console->cursor_col >= CONSOLE_COLS) {
                    console->cursor_col = 0;
                    console->cursor_row++;
                }
            }
            break;
    }
    
    // Check for scroll
    if (console->cursor_row >= CONSOLE_ROWS) {
        need_scroll = true;
    }
    
    if (need_scroll) {
        // Scroll up: move all rows up by one
        for (int row = 0; row < CONSOLE_ROWS - 1; row++) {
            memcpy(console->text_buffer[row], console->text_buffer[row + 1], CONSOLE_COLS);
        }
        // Clear last row
        memset(console->text_buffer[CONSOLE_ROWS - 1], ' ', CONSOLE_COLS);
        console->text_buffer[CONSOLE_ROWS - 1][CONSOLE_COLS] = '\0';
        console->cursor_row = CONSOLE_ROWS - 1;
        
        // Re-render entire screen and flip
        render_screen();
        // Always flip on scroll
        if (!console->defer_flip) {
            lcd_console_flip_buffer();
        }
    } else {
        // Only update affected lines in buffer
        if (old_row != console->cursor_row) {
            render_line(old_row);
        }
        render_line(console->cursor_row);
        
        // Only flip if not in batch mode
        if (!console->defer_flip) {
            lcd_console_flip_buffer();
        }
    }
    
    xSemaphoreGive(console->mutex);
}

void lcd_console_print(const char *str)
{
    if (!str || !console || !console->initialized) {
        return;
    }
    
    // Batch mode: defer per-char flips, do ONE flip at the end
    console->defer_flip = true;
    
    while (*str) {
        lcd_console_putchar(*str++);
    }
    
    // Now do the single flip for the entire string
    console->defer_flip = false;
    
    // Render final state and flip once
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    render_screen();
    xSemaphoreGive(console->mutex);
}

void lcd_console_set_cursor(int col, int row)
{
    if (!console) return;
    
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    
    if (col >= 0 && col < CONSOLE_COLS) {
        console->cursor_col = col;
    }
    if (row >= 0 && row < CONSOLE_ROWS) {
        console->cursor_row = row;
    }
    
    xSemaphoreGive(console->mutex);
}

void lcd_console_get_cursor(int *col, int *row)
{
    if (!console) return;
    
    if (col) *col = console->cursor_col;
    if (row) *row = console->cursor_row;
}

void lcd_console_scroll_up(void)
{
    if (!console || !console->initialized) return;
    
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    
    for (int row = 0; row < CONSOLE_ROWS - 1; row++) {
        memcpy(console->text_buffer[row], console->text_buffer[row + 1], CONSOLE_COLS);
    }
    memset(console->text_buffer[CONSOLE_ROWS - 1], ' ', CONSOLE_COLS);
    
    render_screen();
    
    xSemaphoreGive(console->mutex);
}

void lcd_console_set_colors(uint32_t fg_color, uint32_t bg_color)
{
    if (!console) return;
    
    console->fg_color = rgb888_to_rgb565(fg_color);
    console->bg_color = rgb888_to_rgb565(bg_color);
}

void lcd_console_cursor_enable(bool enable)
{
    if (!console) return;
    
    console->cursor_visible = enable;
}

void lcd_console_refresh(void)
{
    if (!console || !console->initialized) return;
    
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    render_screen();
    xSemaphoreGive(console->mutex);
}

bool lcd_console_is_initialized(void)
{
    return console != NULL && console->initialized;
}

void lcd_console_get_pins(int *rst_pin, int *bl_pin, int *mosi_pin, int *clk_pin)
{
    if (rst_pin) *rst_pin = LCD_PIN_NUM_RST;
    if (bl_pin) *bl_pin = LCD_PIN_NUM_BL;
    if (mosi_pin) *mosi_pin = LCD_PIN_NUM_MOSI;
    if (clk_pin) *clk_pin = LCD_PIN_NUM_CLK;
}

esp_err_t lcd_console_draw_raw(int x_start, int y_start, int x_end, int y_end,
                               const void *data)
{
    if (!console || !console->initialized || !console->panel_handle || !data) {
        return ESP_ERR_INVALID_STATE;
    }
    // Acquire SPI mutex to prevent concurrent access from other tasks
    // (e.g., lcd_console_print during boot vs video_refresh_task in GFX mode)
    if (console->mutex) {
        xSemaphoreTake(console->mutex, portMAX_DELAY);
    }
    // Draw raw RGB565 data directly to LCD panel
    // Data is assumed to already be in DMA-capable memory
    esp_err_t ret = esp_lcd_panel_draw_bitmap(console->panel_handle, x_start, y_start,
                                               x_end, y_end, data);
    if (console->mutex) {
        xSemaphoreGive(console->mutex);
    }
    return ret;
}
