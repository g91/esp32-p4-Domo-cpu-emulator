/*
 * LCD Console Driver - MIPI DSI Version for 7" 800x480 Display
 * Provides a simple text console interface on MIPI DSI display
 */

#include "lcd_console.h"
#include <string.h>
#include <stdlib.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "esp_log.h"
#include "esp_heap_caps.h"
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_mipi_dsi.h"
#include "esp_lcd_panel_vendor.h"
#include "driver/gpio.h"
#include "driver/ledc.h"
#include "hal/mipi_dsi_types.h"
#include "esp_ldo_regulator.h"

static const char *TAG = "lcd_console";

// Pin Definitions for ESP32-P4-NANO
#define LCD_PIN_NUM_BL      48  // Backlight PWM control (GPIO48)

// MIPI DSI PHY Power (CRITICAL for ESP32-P4)
#define MIPI_DSI_PHY_PWR_LDO_CHAN     3
#define MIPI_DSI_PHY_PWR_LDO_VOLTAGE_MV  2500

// MIPI DSI Configuration
#define LCD_H_RES           800
#define LCD_V_RES           480
#define MIPI_DSI_LANE_NUM   2    // Your display uses 2 lanes
#define MIPI_DSI_LANE_BITRATE_MBPS 500  // Lane bitrate
#define MIPI_DSI_DPI_CLK_MHZ  30  // DPI clock frequency

// Character dimensions
#define CHAR_WIDTH          8
#define CHAR_HEIGHT         16

// 8x16 monospace font - ASCII 32-126 (95 characters)
static const uint8_t font_8x16[][16] = {
    // Space (32)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // ! (33)
    {0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // " (34)
    {0x00,0x63,0x63,0x63,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // # (35)
    {0x00,0x00,0x00,0x36,0x36,0x7F,0x36,0x36,0x36,0x7F,0x36,0x36,0x00,0x00,0x00,0x00},
    // $ (36)
    {0x0C,0x0C,0x3E,0x63,0x61,0x60,0x3E,0x03,0x03,0x43,0x63,0x3E,0x0C,0x0C,0x00,0x00},
    // % (37)
    {0x00,0x00,0x00,0x00,0x00,0x61,0x63,0x06,0x0C,0x18,0x33,0x63,0x00,0x00,0x00,0x00},
    // & (38)
    {0x00,0x00,0x00,0x1C,0x36,0x36,0x1C,0x3B,0x6E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00},
    // ' (39)
    {0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // ( (40)
    {0x00,0x00,0x0C,0x18,0x18,0x30,0x30,0x30,0x30,0x18,0x18,0x0C,0x00,0x00,0x00,0x00},
    // ) (41)
    {0x00,0x00,0x18,0x0C,0x0C,0x06,0x06,0x06,0x06,0x0C,0x0C,0x18,0x00,0x00,0x00,0x00},
    // * (42)
    {0x00,0x00,0x00,0x00,0x42,0x66,0x3C,0xFF,0x3C,0x66,0x42,0x00,0x00,0x00,0x00,0x00},
    // + (43)
    {0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x7E,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // , (44)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00},
    // - (45)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // . (46)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // / (47)
    {0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00},
    // 0 (48)
    {0x00,0x00,0x3C,0x66,0xC3,0xC3,0xDB,0xDB,0xC3,0xC3,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 1 (49)
    {0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00},
    // 2 (50)
    {0x00,0x00,0x3C,0x66,0x06,0x06,0x0C,0x18,0x30,0x60,0x66,0x7E,0x00,0x00,0x00,0x00},
    // 3 (51)
    {0x00,0x00,0x3C,0x66,0x06,0x06,0x1C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 4 (52)
    {0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00},
    // 5 (53)
    {0x00,0x00,0x7E,0x60,0x60,0x60,0x7C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 6 (54)
    {0x00,0x00,0x1C,0x30,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 7 (55)
    {0x00,0x00,0x7E,0x66,0x06,0x0C,0x0C,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00},
    // 8 (56)
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 9 (57)
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3E,0x06,0x06,0x06,0x0C,0x38,0x00,0x00,0x00,0x00},
    // : (58)
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // ; (59)
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00},
    // < (60)
    {0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00},
    // = (61)
    {0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // > (62)
    {0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00},
    // ? (63)
    {0x00,0x00,0x3C,0x66,0x66,0x06,0x0C,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // @ (64)
    {0x00,0x00,0x00,0x3C,0x42,0x5A,0x5A,0x5A,0x5C,0x40,0x40,0x3C,0x00,0x00,0x00,0x00},
    // A (65)
    {0x00,0x00,0x18,0x3C,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // B (66)
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00},
    // C (67)
    {0x00,0x00,0x3C,0x66,0x66,0x60,0x60,0x60,0x60,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // D (68)
    {0x00,0x00,0x78,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0x78,0x00,0x00,0x00,0x00},
    // E (69)
    {0x00,0x00,0x7E,0x60,0x60,0x60,0x78,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00},
    // F (70)
    {0x00,0x00,0x7E,0x60,0x60,0x60,0x78,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00},
    // G (71)
    {0x00,0x00,0x3C,0x66,0x66,0x60,0x60,0x6E,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00},
    // H (72)
    {0x00,0x00,0x66,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // I (73)
    {0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // J (74)
    {0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x6C,0x6C,0x38,0x00,0x00,0x00,0x00},
    // K (75)
    {0x00,0x00,0x66,0x66,0x6C,0x6C,0x78,0x78,0x6C,0x6C,0x66,0x66,0x00,0x00,0x00,0x00},
    // L (76)
    {0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00},
    // M (77)
    {0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // N (78)
    {0x00,0x00,0x66,0x66,0x76,0x76,0x7E,0x6E,0x6E,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // O (79)
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // P (80)
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00},
    // Q (81)
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x6E,0x3C,0x06,0x00,0x00,0x00},
    // R (82)
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x78,0x6C,0x6C,0x66,0x66,0x00,0x00,0x00,0x00},
    // S (83)
    {0x00,0x00,0x3C,0x66,0x60,0x60,0x3C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00},
    // T (84)
    {0x00,0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00},
    // U (85)
    {0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // V (86)
    {0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00},
    // W (87)
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // X (88)
    {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // Y (89)
    {0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00},
    // Z (90)
    {0x00,0x00,0x7E,0x06,0x06,0x0C,0x18,0x30,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00},
    // [ (91)
    {0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00},
    // \ (92)
    {0x00,0x00,0x00,0x80,0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00,0x00,0x00,0x00},
    // ] (93)
    {0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00},
    // ^ (94)
    {0x18,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // _ (95)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},
    // ` (96)
    {0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // a (97)
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00},
    // b (98)
    {0x00,0x00,0x60,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00},
    // c (99)
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00,0x00,0x00,0x00},
    // d (100)
    {0x00,0x00,0x06,0x06,0x06,0x3E,0x66,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00},
    // e (101)
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x66,0x7E,0x60,0x60,0x3C,0x00,0x00,0x00,0x00},
    // f (102)
    {0x00,0x00,0x1C,0x36,0x30,0x30,0x7C,0x30,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00},
    // g (103)
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x3C,0x00,0x00},
    // h (104)
    {0x00,0x00,0x60,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // i (105)
    {0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // j (106)
    {0x00,0x00,0x0C,0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x6C,0x6C,0x38,0x00,0x00},
    // k (107)
    {0x00,0x00,0x60,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0x66,0x00,0x00,0x00,0x00},
    // l (108)
    {0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // m (109)
    {0x00,0x00,0x00,0x00,0x00,0x6C,0xFE,0xD6,0xD6,0xD6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // n (110)
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // o (111)
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00},
    // p (112)
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x00,0x00},
    // q (113)
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x06,0x00,0x00},
    // r (114)
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00},
    // s (115)
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x60,0x60,0x3C,0x06,0x06,0x7C,0x00,0x00,0x00,0x00},
    // t (116)
    {0x00,0x00,0x00,0x30,0x30,0x7C,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00},
    // u (117)
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00},
    // v (118)
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00},
    // w (119)
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00},
    // x (120)
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x3C,0x3C,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // y (121)
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x3E,0x06,0x0C,0x78,0x00,0x00},
    // z (122)
    {0x00,0x00,0x00,0x00,0x00,0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00,0x00,0x00,0x00},
    // { (123)
    {0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00},
    // | (124)
    {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00},
    // } (125)
    {0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00},
    // ~ (126)
    {0x00,0x00,0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
};

typedef struct {
    esp_lcd_panel_handle_t panel_handle;
    esp_lcd_dsi_bus_handle_t dsi_bus;
    esp_lcd_panel_io_handle_t io_handle;
    esp_ldo_channel_handle_t ldo_mipi_phy;  // LDO for MIPI DSI PHY power
    uint16_t *frame_buffer;  // Single framebuffer for DSI DPI
    char text_buffer[CONSOLE_ROWS][CONSOLE_COLS + 1];
    int cursor_row;
    int cursor_col;
    bool cursor_visible;
    uint16_t fg_color;  // RGB565
    uint16_t bg_color;  // RGB565
    SemaphoreHandle_t mutex;
    bool initialized;
} lcd_console_t;

static lcd_console_t *console = NULL;

// Convert RGB888 to RGB565
static inline uint16_t rgb888_to_rgb565(uint32_t rgb888)
{
    uint8_t r = (rgb888 >> 16) & 0xFF;
    uint8_t g = (rgb888 >> 8) & 0xFF;
    uint8_t b = rgb888 & 0xFF;
    
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}

// Swap bytes for RGB565 (if needed)
static inline uint16_t swap_rgb565(uint16_t color)
{
    return (color >> 8) | (color << 8);
}

// Draw 8x16 character at pixel position
static void draw_char(int x, int y, char c, uint16_t fg, uint16_t bg)
{
    if (!console || !console->frame_buffer) return;
    if (x < 0 || x >= LCD_H_RES - 8 || y < 0 || y >= LCD_V_RES - 16) return;
    
    int char_index = c - 32;
    if (char_index < 0 || char_index >= 95) {
        char_index = 0; // Default to space
    }
    
    const uint8_t *glyph = font_8x16[char_index];
    
    for (int row = 0; row < 16; row++) {
        uint8_t byte = glyph[row];
        for (int col = 0; col < 8; col++) {
            uint16_t color = (byte & (0x80 >> col)) ? fg : bg;
            int pixel_x = x + col;
            int pixel_y = y + row;
            console->frame_buffer[pixel_y * LCD_H_RES + pixel_x] = color;
        }
    }
}

// Render a line of text
static void render_line(int row)
{
    if (!console || row < 0 || row >= CONSOLE_ROWS) return;
    
    int y = row * CHAR_HEIGHT;
    for (int col = 0; col < CONSOLE_COLS; col++) {
        int x = col * CHAR_WIDTH;
        char c = console->text_buffer[row][col];
        draw_char(x, y, c, console->fg_color, console->bg_color);
    }
}

// Render entire screen
static void render_screen(void)
{
    if (!console) return;
    
    for (int row = 0; row < CONSOLE_ROWS; row++) {
        render_line(row);
    }
    
    // Draw cursor if visible
    if (console->cursor_visible) {
        int x = console->cursor_col * CHAR_WIDTH;
        int y = console->cursor_row * CHAR_HEIGHT + 14;  // Underline cursor
        for (int i = 0; i < CHAR_WIDTH; i++) {
            console->frame_buffer[y * LCD_H_RES + x + i] = console->fg_color;
        }
    }
}

// Flip framebuffer to display
static void lcd_console_flip_buffer(void)
{
    if (!console || !console->panel_handle) return;
    
    // Send framebuffer to DSI panel
    esp_lcd_panel_draw_bitmap(console->panel_handle, 0, 0, LCD_H_RES, LCD_V_RES, console->frame_buffer);
}

// Initialize backlight PWM
static void init_backlight(void)
{
    ledc_timer_config_t ledc_timer = {
        .speed_mode       = LEDC_LOW_SPEED_MODE,
        .timer_num        = LEDC_TIMER_0,
        .duty_resolution  = LEDC_TIMER_10_BIT,
        .freq_hz          = 5000,
        .clk_cfg          = LEDC_AUTO_CLK
    };
    ESP_ERROR_CHECK(ledc_timer_config(&ledc_timer));
    
    ledc_channel_config_t ledc_channel = {
        .speed_mode     = LEDC_LOW_SPEED_MODE,
        .channel        = LEDC_CHANNEL_0,
        .timer_sel      = LEDC_TIMER_0,
        .intr_type      = LEDC_INTR_DISABLE,
        .gpio_num       = LCD_PIN_NUM_BL,
        .duty           = 0,
        .hpoint         = 0
    };
    ESP_ERROR_CHECK(ledc_channel_config(&ledc_channel));
    
    // Set to 80% brightness
    ESP_ERROR_CHECK(ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 820));
    ESP_ERROR_CHECK(ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0));
}

esp_err_t lcd_console_init(void)
{
    esp_err_t ret;
    
    if (console != NULL) {
        ESP_LOGI(TAG, "LCD console already initialized");
        return ESP_OK;
    }
    
    ESP_LOGI(TAG, "Initializing MIPI DSI LCD console (800x480)...");
    
    // Allocate console structure
    console = (lcd_console_t *)heap_caps_calloc(1, sizeof(lcd_console_t), MALLOC_CAP_DEFAULT);
    if (!console) {
        ESP_LOGE(TAG, "Failed to allocate console structure");
        return ESP_ERR_NO_MEM;
    }
    
    // Allocate framebuffer in PSRAM
    console->frame_buffer = (uint16_t *)heap_caps_malloc(LCD_H_RES * LCD_V_RES * sizeof(uint16_t), 
                                                          MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    if (!console->frame_buffer) {
        ESP_LOGE(TAG, "Failed to allocate framebuffer");
        free(console);
        console = NULL;
        return ESP_ERR_NO_MEM;
    }
    memset(console->frame_buffer, 0, LCD_H_RES * LCD_V_RES * sizeof(uint16_t));
    
    // Initialize text buffer
    for (int i = 0; i < CONSOLE_ROWS; i++) {
        memset(console->text_buffer[i], ' ', CONSOLE_COLS);
        console->text_buffer[i][CONSOLE_COLS] = '\0';
    }
    
    console->cursor_row = 0;
    console->cursor_col = 0;
    console->cursor_visible = true;
    console->fg_color = rgb888_to_rgb565(0x00FF00);  // Green
    console->bg_color = rgb888_to_rgb565(0x000000);  // Black
    console->mutex = xSemaphoreCreateMutex();
    
    // Step 1: Power on MIPI DSI PHY (CRITICAL for ESP32-P4!)
    ESP_LOGI(TAG, "Powering on MIPI DSI PHY via LDO channel %d", MIPI_DSI_PHY_PWR_LDO_CHAN);
    esp_ldo_channel_config_t ldo_mipi_phy_config = {
        .chan_id = MIPI_DSI_PHY_PWR_LDO_CHAN,
        .voltage_mv = MIPI_DSI_PHY_PWR_LDO_VOLTAGE_MV,
    };
    ret = esp_ldo_acquire_channel(&ldo_mipi_phy_config, &console->ldo_mipi_phy);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to acquire LDO channel for MIPI DSI PHY: %s", esp_err_to_name(ret));
        free(console->frame_buffer);
        free(console);
        console = NULL;
        return ret;
    }
    ESP_LOGI(TAG, "MIPI DSI PHY powered on");
    
    // Step 2: Initialize MIPI DSI bus
    esp_lcd_dsi_bus_config_t bus_config = {
        .bus_id = 0,
        .num_data_lanes = MIPI_DSI_LANE_NUM,
        .phy_clk_src = MIPI_DSI_PHY_PLLREF_CLK_SRC_DEFAULT,  // Use XTAL for ESP32-P4 v1.3
        .lane_bit_rate_mbps = MIPI_DSI_LANE_BITRATE_MBPS,
    };
    ret = esp_lcd_new_dsi_bus(&bus_config, &console->dsi_bus);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create MIPI DSI bus: %s", esp_err_to_name(ret));
        return ret;
    }
    ESP_LOGI(TAG, "MIPI DSI bus created");
    
    // Step 3: Create DBI (command) interface
    esp_lcd_dbi_io_config_t dbi_config = {
        .virtual_channel = 0,
        .lcd_cmd_bits = 8,
        .lcd_param_bits = 8,
    };
    ret = esp_lcd_new_panel_io_dbi(console->dsi_bus, &dbi_config, &console->io_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create DBI interface: %s", esp_err_to_name(ret));
        return ret;
    }
    ESP_LOGI(TAG, "MIPI DSI DBI interface created");
    
    // Step 4: Initialize backlight early
    init_backlight();
    
    // Step 5: Create DPI (video) panel
    esp_lcd_dpi_panel_config_t dpi_config = {
        .virtual_channel = 0,
        .dpi_clk_src = MIPI_DSI_DPI_CLK_SRC_DEFAULT,
        .dpi_clock_freq_mhz = MIPI_DSI_DPI_CLK_MHZ,
        .pixel_format = LCD_COLOR_PIXEL_FORMAT_RGB565,
        .in_color_format = LCD_COLOR_FMT_RGB565,   // Format in frame buffer
        .out_color_format = LCD_COLOR_FMT_RGB565,  // Format panel accepts
        .num_fbs = 1,
        .video_timing = {
            .h_size = LCD_H_RES,
            .v_size = LCD_V_RES,
            .hsync_back_porch = 46,
            .hsync_pulse_width = 2,
            .hsync_front_porch = 210,
            .vsync_back_porch = 23,
            .vsync_pulse_width = 2,
            .vsync_front_porch = 22,
        },
        .flags = {
            .use_dma2d = 0,
        },
    };
    ret = esp_lcd_new_panel_dpi(console->dsi_bus, &dpi_config, &console->panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create DPI panel: %s", esp_err_to_name(ret));
        return ret;
    }
    ESP_LOGI(TAG, "MIPI DSI DPI panel created");
    
    // Step 6: Initialize and turn on display
    ret = esp_lcd_panel_init(console->panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize panel: %s", esp_err_to_name(ret));
        return ret;
    }
    ret = esp_lcd_panel_disp_on_off(console->panel_handle, true);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to turn on display: %s", esp_err_to_name(ret));
        return ret;
    }
    ESP_LOGI(TAG, "MIPI DSI panel initialized and turned on");
    
    // Clear framebuffer and display
    render_screen();
    lcd_console_flip_buffer();
    
    console->initialized = true;
    ESP_LOGI(TAG, "MIPI DSI LCD console initialized successfully");
    
    return ESP_OK;
}

void lcd_console_clear(void)
{
    if (!console || !console->initialized) return;
    
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    
    for (int i = 0; i < CONSOLE_ROWS; i++) {
        memset(console->text_buffer[i], ' ', CONSOLE_COLS);
    }
    console->cursor_row = 0;
    console->cursor_col = 0;
    
    render_screen();
    lcd_console_flip_buffer();
    
    xSemaphoreGive(console->mutex);
}

void lcd_console_putchar(char c)
{
    if (!console || !console->initialized) return;
    
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    
    int old_row = console->cursor_row;
    bool need_scroll = false;
    
    switch (c) {
        case '\n':
            console->cursor_col = 0;
            console->cursor_row++;
            break;
            
        case '\r':
            console->cursor_col = 0;
            break;
            
        case '\t':
            console->cursor_col = (console->cursor_col + 4) & ~3;
            if (console->cursor_col >= CONSOLE_COLS) {
                console->cursor_col = 0;
                console->cursor_row++;
            }
            break;
            
        case '\b':
            if (console->cursor_col > 0) {
                console->cursor_col--;
                console->text_buffer[console->cursor_row][console->cursor_col] = ' ';
            }
            break;
            
        default:
            if (c >= 32 && c <= 126) {
                console->text_buffer[console->cursor_row][console->cursor_col] = c;
                console->cursor_col++;
                if (console->cursor_col >= CONSOLE_COLS) {
                    console->cursor_col = 0;
                    console->cursor_row++;
                }
            }
            break;
    }
    
    if (console->cursor_row >= CONSOLE_ROWS) {
        need_scroll = true;
    }
    
    if (need_scroll) {
        for (int row = 0; row < CONSOLE_ROWS - 1; row++) {
            memcpy(console->text_buffer[row], console->text_buffer[row + 1], CONSOLE_COLS);
        }
        memset(console->text_buffer[CONSOLE_ROWS - 1], ' ', CONSOLE_COLS);
        console->cursor_row = CONSOLE_ROWS - 1;
        render_screen();
    } else {
        if (old_row != console->cursor_row) {
            render_line(old_row);
        }
        render_line(console->cursor_row);
        lcd_console_flip_buffer();
    }
    
    xSemaphoreGive(console->mutex);
}

void lcd_console_print(const char *str)
{
    if (!str || !console || !console->initialized) return;
    
    while (*str) {
        lcd_console_putchar(*str++);
    }
}

void lcd_console_set_cursor(int col, int row)
{
    if (!console) return;
    
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    
    if (col >= 0 && col < CONSOLE_COLS) {
        console->cursor_col = col;
    }
    if (row >= 0 && row < CONSOLE_ROWS) {
        console->cursor_row = row;
    }
    
    xSemaphoreGive(console->mutex);
}

void lcd_console_get_cursor(int *col, int *row)
{
    if (!console) return;
    
    if (col) *col = console->cursor_col;
    if (row) *row = console->cursor_row;
}

void lcd_console_scroll_up(void)
{
    if (!console || !console->initialized) return;
    
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    
    for (int row = 0; row < CONSOLE_ROWS - 1; row++) {
        memcpy(console->text_buffer[row], console->text_buffer[row + 1], CONSOLE_COLS);
    }
    memset(console->text_buffer[CONSOLE_ROWS - 1], ' ', CONSOLE_COLS);
    
    render_screen();
    lcd_console_flip_buffer();
    
    xSemaphoreGive(console->mutex);
}

void lcd_console_set_colors(uint32_t fg_color, uint32_t bg_color)
{
    if (!console) return;
    
    console->fg_color = rgb888_to_rgb565(fg_color);
    console->bg_color = rgb888_to_rgb565(bg_color);
}

void lcd_console_cursor_enable(bool enable)
{
    if (!console) return;
    console->cursor_visible = enable;
}

void lcd_console_refresh(void)
{
    if (!console || !console->initialized) return;
    
    xSemaphoreTake(console->mutex, portMAX_DELAY);
    render_screen();
    lcd_console_flip_buffer();
    xSemaphoreGive(console->mutex);
}

bool lcd_console_is_initialized(void)
{
    return console != NULL && console->initialized;
}
